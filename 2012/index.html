<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Meta Robots Tag -->
  <meta name="robots" content="all">

  <!-- Site Author -->
  <meta name="author" content="bo">

  <!-- Atom Feed -->
  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Bo Jeanes Feed">
  
  <!-- Stylesheet -->
  <link rel="stylesheet" href="/assets/css/minimal.css">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="/favicon.png">

  <!-- Analytics -->
  

  <!-- SEO -->
  <!-- Begin Jekyll SEO tag v2.3.0 -->
<title>Bo Jeanes</title>
<meta property="og:title" content="Bo Jeanes" />
<meta name="author" content="Bo Jeanes" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="https://bjeanes.com/2012/" />
<meta property="og:url" content="https://bjeanes.com/2012/" />
<meta property="og:site_name" content="Bo Jeanes" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2012-01-01T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@bjeanes" />
<meta name="twitter:creator" content="@bjeanes" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"https://bjeanes.com/2012/"},"description":null,"@type":"BlogPosting","url":"https://bjeanes.com/2012/","name":null,"headline":"Bo Jeanes","dateModified":"2012-01-01T00:00:00+00:00","datePublished":"2012-01-01T00:00:00+00:00","sameAs":null,"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://avatars2.githubusercontent.com/u/2560?s=200&v=4"},"name":"Bo Jeanes"},"image":null,"author":{"@type":"Person","name":"Bo Jeanes"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body class="black-90 ">

<div class="flex flex-column items-center">
  <div class="mw7 w-100 ph3 ph4-ns">
    <h1 class="f5 fw4 lh-title mb0 pb2 bb b--light-gray">Posts from 2012</h1>

    
    <a class="link black-80 hover-silver" href="/2012/11/talk-ssh-can-do-that/">
      <article class="f5 lh-copy fw3 pb4 bb b--light-gray">
        <div class="f6 fw6 lh-title ttu tracked mv4"><time>Nov 2012</time></div>
        <h3 class="f3 fw6 lh-title mb0">Talk: SSH Can Do That?</h3>
        <p class="f5 fw3 lh-copy mv2">Last night I gave a talk on the darker side of SSH at <a href="www.meetup.com/ChicagoSC/">ChiSC meetup group</a>.

Here’s a video version (better quality one coming soon) for those who are interested:

<iframe src="http://player.vimeo.com/video/54505525?byline=0&amp;portrait=0&amp;badge=0&amp;color=cc7833" width="500" height="281" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe>
</p>
  
        <div class="f6 fw3 silver mt0">
          
          <time>29 Nov 2012</time>
          
          <span class="ttl">&middot; 



  
	  Less than 1 min read
	

</span>
        </div>
      </article>
    </a>
    
    <a class="link black-80 hover-silver" href="/2012/09/call-clojure-function-on-a-timer/">
      <article class="f5 lh-copy fw3 pb4 bb b--light-gray">
        <div class="f6 fw6 lh-title ttu tracked mv4"><time>Sep 2012</time></div>
        <h3 class="f3 fw6 lh-title mb0">Call Clojure function on a timer</h3>
        <p class="f5 fw3 lh-copy mv2">In Clojure, I didn’t see a nice way to simply call a function on a timer (e.g. to poll for changes in another service).

I didn’t find something in <code class="highlighter-rouge">clojure.core</code> to achieve this readily (but <code class="highlighter-rouge">clojure.core</code> is quite big, so I may have missed something obvious — let me know), so I whipped up the following to put in my project’s <code class="highlighter-rouge">util.clj</code> file:

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">tick</span><span class="w">
  </span><span class="s">"Call f with args every ms. First call will be after ms"</span><span class="w">
  </span><span class="p">[</span><span class="n">ms</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">

  </span><span class="p">(</span><span class="nf">future</span><span class="w">
    </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nf">repeatedly</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">args</span><span class="p">))]</span><span class="w">
      </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="n">ms</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">f</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">tick-now</span><span class="w">
  </span><span class="s">"Call f with args every ms. First call will be immediately (and blocking)"</span><span class="w">
  </span><span class="p">[</span><span class="n">ms</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">

  </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">tick</span><span class="w"> </span><span class="n">ms</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

There are two variants. <code class="highlighter-rouge">tick</code> waits <code class="highlighter-rouge">ms</code> milliseconds and then calls <code class="highlighter-rouge">f</code> with <code class="highlighter-rouge">args</code> and repeats indefinitely. <code class="highlighter-rouge">tick-now</code> does the same thing except it calls <code class="highlighter-rouge">f</code> with <code class="highlighter-rouge">args</code> <em>before</em> starting the timer.

They are simple to use:

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">tick</span><span class="w"> </span><span class="mi">500</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"hi"</span><span class="p">))</span><span class="w">
</span><span class="c1">; 500ms delay</span><span class="w">
</span><span class="n">hi</span><span class="w">
</span><span class="c1">; 500ms delay</span><span class="w">
</span><span class="n">hi</span><span class="w">
</span><span class="c1">; 500ms delay</span><span class="w">
</span><span class="n">hi</span><span class="w">
</span><span class="n">...</span><span class="w">
</span></code></pre></div></div>

In my project, I’m using them like so:

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">start-fetchers</span><span class="w">
  </span><span class="p">[</span><span class="n">api-token</span><span class="p">]</span><span class="w">

  </span><span class="p">(</span><span class="nf">future</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">minutes</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="mi">60</span><span class="w"> </span><span class="mi">1000</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nf">tick-now</span><span class="w"> </span><span class="p">(</span><span class="nf">minutes</span><span class="w"> </span><span class="mi">60</span><span class="p">)</span><span class="w">
                </span><span class="n">update-project-list!</span><span class="w">
                </span><span class="n">api-token</span><span class="p">)</span><span class="w">

      </span><span class="p">(</span><span class="nf">tick-now</span><span class="w"> </span><span class="p">(</span><span class="nf">minutes</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
                </span><span class="n">fetch-milestones!</span><span class="w">
                </span><span class="n">api-token</span><span class="w">
                </span><span class="n">projects-to-fetch</span><span class="w">
                </span><span class="n">milestones-by-project</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>
</p>
  
        <div class="f6 fw3 silver mt0">
          
          <time>20 Sep 2012</time>
          
          <span class="ttl">&middot; 



  
	  1 min read
	

</span>
        </div>
      </article>
    </a>
    
    <a class="link black-80 hover-silver" href="/2012/09/pure-evil/">
      <article class="f5 lh-copy fw3 pb4 bb b--light-gray">
        <div class="f6 fw6 lh-title ttu tracked mv4"><time>Sep 2012</time></div>
        <h3 class="f3 fw6 lh-title mb0">Pure Evil</h3>
        <p class="f5 fw3 lh-copy mv2">I love Vim. I take that back — I love <strong>modal editing</strong>.

Actually, I think very few people like <em>Vim</em>, it just happens to be the best kid on the block at modal editing. But, after using Vim (and, God, does it take a while to learn to <em>use</em> it), you are reduced to a <q><a href="http://haldean.org/docstore/?vim-problems">pathetic teary wreck every time [you] have to use a text editor that isn’t vim</a></q>.

And why <em>is</em> it so debilitating to use something other than Vim for those who have honed their modal editing skills? Frankly, magic sauce of Vim is (mostly) made up from a few quite simple ingredients: motions, text objects, operators. There are plenty of cool tricks hidden inside Vim, but those three main things are the things you really miss, consistently, when using something else.

Every now and then, when forced outside of the comforting (yet somehow cold) embrace of Vim, the Vimmer flirts with Sublime Text 2’s <a href="http://www.sublimetext.com/docs/2/vintage.html">vintage mode</a> or <a href="http://plugins.intellij.net/plugin/?id=164">IdeaVIM</a>. We may even be impressed — but, eventually, something falls apart and the abstraction leaks.

Usually, this failure happens because the Vi(m) emulation layer often doesn’t implement motions, text objects, and operators. They just implement some keystrokes that appear to do the same thing in the same way — until you try something the developer didn’t preempt.

If I could have an editor that did these things <em>properly</em>, I would have no real attachment to Vim. I have other things about Vim that I love and would hate to lose but they aren’t unique and other editors (can) have them, too.

Luckily for me, I’ve been doing too much Clojure to ignore Emacs forever and 2 weeks ago, I switched. Here’s how it played out:

<blockquote>
  Nope — not for me… But, wait! Let us try this <a href="http://emacswiki.org/emacs/Evil">Evil Mode</a> so we can mock their pitiful attempt at modal editing (*evil laugh here*).  What’s this‽ It’s actually good!
</blockquote>

Inner dialogs aside, I’m not kidding; Evil Mode is stunning. It doesn’t have <em>everything</em> — but everything that it does have is built up using the same <strike>functions</strike> macros that you can use to extend it. Those are: <code class="highlighter-rouge">(evil-define-state)</code> (“mode” is an existing term in Emacs so what Vim calls modes, Evil Mode calls “states”), <code class="highlighter-rouge">(evil-define-motion)</code>, <code class="highlighter-rouge">(evil-define-operator)</code>, <code class="highlighter-rouge">(evil-define-text-object)</code>, and a <a href="https://gitorious.org/evil/evil/blobs/raw/doc/doc/evil.pdf">few others</a>.

Evil Mode correctly implements the plumbing to wire these things together so that the Vim “language” which becomes natural and reflexive (e.g. <code class="highlighter-rouge">di”</code> -&gt; “<strong>d</strong>elete <strong>i</strong>nside double quotes”, <code class="highlighter-rouge">vt </code> -&gt; “<strong>v</strong>isually select <strong>t</strong>ill space`) is completely preserved. If you wanted to define a new text object (e.g. a Ruby block), it is trivial to do so and all of the motions and operators will work flawlessly with it immediately. Frankly, it’s not even that nice in Vim.

At the end of the day, I’ve always hated things like VimScript and Vim’s single-threadedness but I could never walk away from a truly powerful (and mostly extensible) modal editing system. Now, that has changed; I get ELisp (which, for all its faults, is exponentially better than VimScript), a saner package system, and a level of extensibility that, by design, can never be matched by Vim. All that and I don’t have to give up modal editing? Hell yes!

Bonus points: one of the “states” that Evil implements is an Emacs state; this leaves Emacs and all it’s default behavior and keymappings 100% intact, meaning you can pair fearlessly with Emacsen, or slowly learn more about the Emacs way of doing things, if desirable.

So far, I’ve rarely noticed I’m not in Vim and am constantly surprised when I employ Vim reflexes in Emacs and they work <em>exactly</em> as expected or better (seriously, try <code class="highlighter-rouge">:%s/foo/bar/g</code> in Evil mode and tell me you don’t squeal with joy).

I refuse to pick a single side, so I’m picking both. I’m going to edit modally in Emacs and I’m going to be happy doing it! I don’t care if I simultaneously piss off Vim users and Emacs users — hell, they need more things in common anyway…
</p>
  
        <div class="f6 fw3 silver mt0">
          
          <time>7 Sep 2012</time>
          
          <span class="ttl">&middot; 



  
	  3 min read
	

</span>
        </div>
      </article>
    </a>
    
    <a class="link black-80 hover-silver" href="/2012/09/happier-as-a-hacker/">
      <article class="f5 lh-copy fw3 pb4 bb b--light-gray">
        <div class="f6 fw6 lh-title ttu tracked mv4"><time>Sep 2012</time></div>
        <h3 class="f3 fw6 lh-title mb0">Happier as a Hacker</h3>
        <p class="f5 fw3 lh-copy mv2">I’ve grown a lot in the last few years, personally and, specifically, in my career. My values have changed and it’s affected the way I think and work.

There has been a gradual progression towards caring more and more about the Right Way™ to do things. For example, more than ever before, I value simplicity and clarity over ease and cleverness (an epidemic that greatly afflicts the Ruby community, in my opinion).

But, these values have come at a cost to me. Somewhere along the way, I complacently let <em>getting it right</em> become far more important than <em>getting it done</em>.” Don’t get me wrong, getting things right is very important — where I went wrong was valuing getting it right the <strong>first</strong> time.

It may not plague others to the extent that it has me, but this misplaced obsession has gotten in the way of progress. It’s caused a type of analysis paralysis not unlike writers’ block; I discard ideas and directions too early because they aren’t “good enough.” But exploring a potentially bad direction is still being better than having no direction — which is the only place you end up when you discard ideas before they have a chance to blossom.

In the eternal words of <a href="http://en.wikipedia.org/wiki/Into_the_Woods">Little Red Ridinghood</a>:

<blockquote>
  Isn’t it nice to know a lot?<br />
And a little bit not.
</blockquote>

I was happier as a hacker, blissfully ignorant as I was, because I got things done.

It’s time to become a hacker again; it’s time to be creative and explorative, and work towards <em>approximating</em> the Right Way™, iteratively. Truly, this is one of the great realizations of Agile — focus on progress instead of planning and pre-empting every possible outcome.

I can’t forget that.
</p>
  
        <div class="f6 fw3 silver mt0">
          
          <time>6 Sep 2012</time>
          
          <span class="ttl">&middot; 



  
	  1 min read
	

</span>
        </div>
      </article>
    </a>
    
    <a class="link black-80 hover-silver" href="/2012/09/motivate-your-lazy-sequences/">
      <article class="f5 lh-copy fw3 pb4 bb b--light-gray">
        <div class="f6 fw6 lh-title ttu tracked mv4"><time>Sep 2012</time></div>
        <h3 class="f3 fw6 lh-title mb0">Motivate your lazy sequences</h3>
        <p class="f5 fw3 lh-copy mv2">I <em>love</em> Clojure’s laziness.

Recently, I’ve been using <code class="highlighter-rouge">lazy-seq</code>  to consume remote collections via APIs, fetching pages of data transparently and only as needed. <a href="http://gfredericks.com/">Gary Fredericks</a>, <a href="http://mikelikesbikes.com/">Mike Busch</a>, and I applied this to a project of ours that had to crunch tens of thousands of records from Salesforce. I’m also doing something similar with a personal project that has to fetch a lot of Pivotal Tracker stories to <code class="highlighter-rouge">reduce</code> them.

In cases like these, consuming (potentially unbounded) resources in a lazy manner allows one to start processing data earlier and to make as few requests as possible to get only the data you need.

<h2 id="mostly-lazy"><em>Mostly</em> Lazy</h2>

I want to talk about a neat little thing I did in my project to get a nice little performance boost on top of this laziness, without having to think about any low-level concurrency concerns.

<h3 id="laziness">Laziness</h3>

Here’s a piece of code that provides an “infinite” lazy sequence. In this case, it is of tweets:

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clj-http.client</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">http</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">tweets-for</span><span class="w">
  </span><span class="p">([</span><span class="n">user</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">tweets-for</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="n">nil</span><span class="p">))</span><span class="w">
  </span><span class="p">([</span><span class="n">user</span><span class="w"> </span><span class="n">last-tweet-id</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nf">lazy-seq</span><span class="w">
      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">url</span><span class="w"> </span><span class="s">"http://api.twitter.com/1/statuses/user_timeline.json"</span><span class="w">
            </span><span class="n">params</span><span class="w"> </span><span class="p">{</span><span class="no">:limit</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="no">:screen_name</span><span class="w"> </span><span class="n">user</span><span class="p">}</span><span class="w">
            </span><span class="n">params</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">last-tweet-id</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="no">:max_id</span><span class="w"> </span><span class="n">last-tweet-id</span><span class="p">)</span><span class="w"> </span><span class="n">params</span><span class="p">)</span><span class="w">
            </span><span class="n">response</span><span class="w"> </span><span class="p">(</span><span class="nf">http/get</span><span class="w"> </span><span class="n">url</span><span class="w"> </span><span class="p">{</span><span class="no">:query-params</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="no">:json</span><span class="p">})</span><span class="w">
            </span><span class="n">tweets</span><span class="w"> </span><span class="p">(</span><span class="no">:body</span><span class="w"> </span><span class="n">response</span><span class="p">)]</span><span class="w">

        </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nf">not-empty</span><span class="w"> </span><span class="n">tweets</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nb">concat</span><span class="w"> </span><span class="n">tweets</span><span class="w">
                  </span><span class="p">(</span><span class="nf">tweets-for</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="p">(</span><span class="no">:id</span><span class="w"> </span><span class="p">(</span><span class="nb">last</span><span class="w"> </span><span class="n">tweets</span><span class="p">)))))))))</span><span class="w">
</span></code></pre></div></div>

So that’s cool. Now, note the following performance characteristics when contemplating the next section:

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">my-tweets</span><span class="w"> </span><span class="p">(</span><span class="nf">tweets-for</span><span class="w"> </span><span class="s">"bjeanes"</span><span class="p">))</span><span class="w">

</span><span class="c1">;; The following returns after a delay while we fetch the first page:</span><span class="w">
</span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">my-tweets</span><span class="p">)</span><span class="w"> </span><span class="c1">;=&gt; {:text "Tweet 0" ...}</span><span class="w">

</span><span class="c1">;; This returns instantly because our `tweets-for` function fetches 10 tweets per page:</span><span class="w">
</span><span class="p">(</span><span class="nb">nth</span><span class="w"> </span><span class="n">my-tweets</span><span class="w"> </span><span class="mi">9</span><span class="p">)</span><span class="w"> </span><span class="c1">;=&gt; {:text "Tweet 9" ...}</span><span class="w">

</span><span class="c1">;; This returns after a delay because this tweet is on the next (still lazily unfetched) page:</span><span class="w">
</span><span class="p">(</span><span class="nb">nth</span><span class="w"> </span><span class="n">my-tweets</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="c1">;=&gt; {:text "Tweet 10" ...}</span><span class="w">
</span></code></pre></div></div>

<h3 id="motivation">Motivation</h3>

So laziness is pretty cool. But, sometimes, things can improve if you are ever so slightly less lazy. What if we could remove that little pause between the 9th and the 10th items in the list where we are just waiting around for the network request to Twitter to complete? We could be using our time to do more CPU-melting tweet crunching! Well, it turns out we can easily do it.

Assume for a moment that we have some calculation (<code class="highlighter-rouge">process</code>) that takes a considerable amount of CPU time to process:

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">process</span><span class="w">
  </span><span class="s">"Do some really hard work with our tweets"</span><span class="w">
  </span><span class="p">[</span><span class="n">tweets</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="n">tweets</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

If we know we will be consuming a substantial amount of the lazy sequence, we could encourage the sequence to go ahead and start realizing the next chunk of our sequence.

This would mean that instead of processing 10 tweets, waiting, processing 10 tweets, waiting, etc.:

<figure class="full tc">
  <img src="https://bjeanes.com/assets/images/lazy.png" alt="Lazy sequences, visualised" />
  
    <figcaption>Lazy sequences
</figcaption>
  
</figure>

… we would be able to process tweets continuously back-to-back:

<figure class="full tc">
  <img src="https://bjeanes.com/assets/images/motivated.png" alt="Motivated sequences, visualised" />
  
    <figcaption>Motivated sequences
</figcaption>
  
</figure>

Wouldn’t also be great if we didn’t have to think about the parallelism at all? To this end, I present <code class="highlighter-rouge">motivate</code>:

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">motivate</span><span class="w">
  </span><span class="s">"Motivate a lazy sequence to seek slightly ahead of the sequence consumer's position."</span><span class="w">
  </span><span class="p">([</span><span class="n">coll</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">motivate</span><span class="w"> </span><span class="n">coll</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
  </span><span class="p">([</span><span class="n">coll</span><span class="w"> </span><span class="n">motivation</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nf">lazy-seq</span><span class="w">
      </span><span class="p">(</span><span class="nf">future</span><span class="w"> </span><span class="p">(</span><span class="nb">nth</span><span class="w"> </span><span class="n">coll</span><span class="w"> </span><span class="n">motivation</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">coll</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">motivate</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">coll</span><span class="p">)</span><span class="w"> </span><span class="n">motivation</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

Let’s compare:

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">time</span><span class="w"> </span><span class="p">(</span><span class="nf">process</span><span class="w"> </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">(</span><span class="nf">tweets-for</span><span class="w"> </span><span class="s">"riblah"</span><span class="p">))))</span><span class="w">
</span><span class="c1">;=&gt; “Elapsed time: 11545.011 msecs"</span><span class="w">
</span><span class="p">(</span><span class="nb">time</span><span class="w"> </span><span class="p">(</span><span class="nf">process</span><span class="w"> </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">(</span><span class="nf">motivate</span><span class="w"> </span><span class="p">(</span><span class="nf">tweets-for</span><span class="w"> </span><span class="s">"riblah"</span><span class="p">)</span><span class="w"> </span><span class="mi">5</span><span class="p">))))</span><span class="w">
</span><span class="c1">;=&gt; "Elapsed time: 10394.769 msecs"</span><span class="w">
</span></code></pre></div></div>

The speed difference is noticeable even when processing only a 100 tweets. If we were doing more than 100 milliseconds/tweet of processing, fetching a lot more data, or dealing with a slow upstream dependency, the speed improvements would be even clearer.

The last (optional) parameter to <code class="highlighter-rouge">motivate</code> is the “motivation factor”. If your CPU-bound work is long-running, this number can be smaller without a noticeable difference. The ideal number depends on how long each IO operation takes and much processing you do with each chunk.

Essentially, the motivation you give to the lazy sequence is a trade-off between waiting for IO and wasting IO; that is, the lower the number, the more likely you are to wait on IO but the higher the number, the more IO you’ll perform unnecessarily (at least, if you aren’t guaranteed to consume the whole sequence.

Hopefully this is handy to someone else out there. I wouldn’t at all be surprised if something like this already existed (<strong>UPDATE</strong> Yup: <a href="http://clojuredocs.org/clojure_core/clojure.core/seque"><code class="highlighter-rouge">seque</code></a>) or if this completely obvious to seasoned Clojurian, but it was a pleasant moment discovering this possibility on my own.
</p>
  
        <div class="f6 fw3 silver mt0">
          
          <time>3 Sep 2012</time>
          
          <span class="ttl">&middot; 



  
	  3 min read
	

</span>
        </div>
      </article>
    </a>
    
    <a class="link black-80 hover-silver" href="/2012/02/factories-breed-complexity/">
      <article class="f5 lh-copy fw3 pb4 bb b--light-gray">
        <div class="f6 fw6 lh-title ttu tracked mv4"><time>Feb 2012</time></div>
        <h3 class="f3 fw6 lh-title mb0">Factories breed complexity</h3>
        <p class="f5 fw3 lh-copy mv2">Having maintainable code is great. Maintainable code allows you to deliver improvements faster, happier, and more reliably.

Furthermore, the measures that developers need to take and the strategies that we have to employ to achieve maintainable code have been understood for years, if not decades. Especially in the realm of object-oriented programming, but certainly not exclusively, most of these principles boil down to reducing coupling and system complexity. A system whose parts are coupled as loosely as possible is a modular system; the parts know little of each other and a lot about themselves and they have thin and specific interfaces between each other.

Test-driven development is one of the many tools at a developer’s disposal to achieve code quality. Unfortunately, there is a lot of naïveté around the benefits of TDD. A lot of developers see TDD as primarily a tool for verifying system correctness. While TDD does of course offer this benefit, and arguably better than retroactive automated testing, the real benefit of TDD is that it offers short feedback loops that guide the design/architecture of the system.

Since it is accepted that a loosely-coupled modular system is a simpler system, it stands that tools, such as TDD, which guide a design towards modularity and simplicity are good tools. A module that is tightly coupled to another is not easily tested in isolation. However, if the isolated tests are written first, it is difficult to write a passing implementation for that module that maintains such a low degree of coupling. Therefore, good TDD should guide you towards a simpler design (though it is certainly not the only way).

Unfortunately, factories work against this goal. Factories debilitate TDD’s ability to give you feedback into the complexity of your design.

To be clear, I am not talking about the <a href="http://en.wikipedia.org/wiki/Factory_method_pattern">Factory Method Pattern</a>
or the <a href="http://en.wikipedia.org/wiki/Abstract_factory_pattern">Abstract Factory Pattern</a> — both of which can be described
as ways to <q src="http://en.wikipedia.org/wiki/Object_creation#Creating_objects">decouple a particular implementation
of an object from code for the creation of such an object</q> (<cite><a href="http://en.wikipedia.org/wiki/Object_creation#Creating_objects">Wikipedia</a></cite>). Instead, I am talking about the “factories” for replacing fixtures in tests — something which has seemingly obsessed the Ruby (Rails, especially) community. The two primary Ruby libraries for factory-based fixture replacement are <a href="https://github.com/thoughtbot/factory_girl">factory_girl</a> and <a href="https://github.com/notahat/machinist">Machinist</a>.

A tool such as Machinist or factory_girl <q>generates data for the attributes you don’t care about, and constructs any necessary associated objects, leaving you to specify only the fields you care about in your test</q> (from Machinist’s own <a href="https://github.com/notahat/machinist/blob/master/README.markdown">README file</a>). This sounds nice at first, because it makes your tests more readable and relevant. However, behind the scenes, these tools are still creating other objects and entities and introducing them into your test environment. By having data and objects in tests that are irrelevant to the functionality that is being tested (in <em>isolation</em>, remember), a developer creates an environment that permits, if not invites, silent dependencies to creep into an implementation.

Furthermore, and perhaps more significantly, by creating objects (and usually entire <em>hierarchies</em> of objects) with such ease and opacity, you are outright masking the dependencies (*cough* complexity *cough* coupling) between your implementation and those entities. If forced to stub out all those intricacies, the system complexity would be screamingly obvious and a developer would quickly avail herself of a rewrite to reduce complexity or thin out the interface.

Instead of having feedback that guides a developer to simplicity, fixture factories seem to guide developers to complexity by masking dependencies as one-line simplicity. In fact, that one (or five, whatever) line setup is a shotgun blast of environmental dependencies that are hidden from the architect. That complexity will come back for revenge after being ignored for so long.

It seems that factory_girl and Machinist exist to make testing components more convenient. This is, at face value, an admirable and desirable goal. However, in unit tests, the cost is too high for any system of considerable size.

Please, do the right thing and avoid the convenience and “fun” of the factory_girl temptress. You will trend towards a simpler system and as a bonus (in fact, an incredible one) your test suite will likely be exponentially faster which, in turn, will breed simplicity by letting you have more feedback more often.

P.S. It shouldn’t go without mention that factories can be absolutely awesome for integration tests. Integration tests aren’t used for guiding system design nor testing in isolation so the drawbacks of these tools drop away. However, both factory_girl and Machinist use RSpec as some of their very first usage examples and this troubles me deeply.

P.P.S. A lot of these arguments can be applied to fixtures too. However, they usually don’t create hordes of objects invisibly and litter your environment with them. Also, they aren’t as slow. But yes, the fewer factories <em>and</em> fixtures in a test, the better.

<strong>Update for clarity</strong>: Firstly, I am absolutely just talking about unit tests. If you are testing code that <em>integrates</em> with ActiveRecord or number of levels of your stack, then factories and fixtures are certainly defensible (though I still prefer to steer clear). Secondly, I’ve tried to be careful about where I use the words simple, easy, complex, and difficult. For the definitions that I intend, please watch (at least the first 10 minutes of) <a href="http://www.infoq.com/presentations/Simple-Made-Easy">Simple Made Easy</a>.
</p>
  
        <div class="f6 fw3 silver mt0">
          
          <time>26 Feb 2012</time>
          
          <span class="ttl">&middot; 



  
	  4 min read
	

</span>
        </div>
      </article>
    </a>
    

  </div>
</div>

<footer class="flex justify-start items-baseline mw7 center w-100 ph3 ph4-ns mt4 mb2 lh-copy">
  <nav class="flex flex-row flex-wrap">
    <span class="f7 fw3 silver mr3 ttc"><a href="https://bjeanes.com/" class="f7 fw5 silver hover-silver link underline-hover" title="Bo Jeanes">Bo jeanes</a> &copy; 2020</span>
    

    
    <span class="f7 fw3 silver mr3">Designed with <a href="https://desiredpersona.com/themes/" class="f7 fw3 silver hover-silver link underline-hover mr3" target="_blank">Minimal Theme</a></span>
    
  </nav>
</footer>

</body>
</html>
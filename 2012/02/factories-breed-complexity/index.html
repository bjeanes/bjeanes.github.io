<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Meta Robots Tag -->
  <meta name="robots" content="all">

  <!-- Site Author -->
  <meta name="author" content="bo">

  <!-- Atom Feed -->
  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Bo Jeanes Feed">
  
  <!-- Stylesheet -->
  <link rel="stylesheet" href="/assets/css/minimal.css">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="/favicon.png">

  <!-- Analytics -->
  

  <!-- SEO -->
  <!-- Begin Jekyll SEO tag v2.3.0 -->
<title>Factories breed complexity | Bo Jeanes</title>
<meta property="og:title" content="Factories breed complexity" />
<meta name="author" content="Bo Jeanes" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Having maintainable code is great. Maintainable code allows you to deliver improvements faster, happier, and more reliably. Furthermore, the measures that developers need to take and the strategies that we have to employ to achieve maintainable code have been understood for years, if not decades. Especially in the realm of object-oriented programming, but certainly not exclusively, most of these principles boil down to reducing coupling and system complexity. A system whose parts are coupled as loosely as possible is a modular system; the parts know little of each other and a lot about themselves and they have thin and specific interfaces between each other. Test-driven development is one of the many tools at a developer’s disposal to achieve code quality. Unfortunately, there is a lot of naïveté around the benefits of TDD. A lot of developers see TDD as primarily a tool for verifying system correctness. While TDD does of course offer this benefit, and arguably better than retroactive automated testing, the real benefit of TDD is that it offers short feedback loops that guide the design/architecture of the system. Since it is accepted that a loosely-coupled modular system is a simpler system, it stands that tools, such as TDD, which guide a design towards modularity and simplicity are good tools. A module that is tightly coupled to another is not easily tested in isolation. However, if the isolated tests are written first, it is difficult to write a passing implementation for that module that maintains such a low degree of coupling. Therefore, good TDD should guide you towards a simpler design (though it is certainly not the only way). Unfortunately, factories work against this goal. Factories debilitate TDD’s ability to give you feedback into the complexity of your design. To be clear, I am not talking about the Factory Method Pattern or the Abstract Factory Pattern — both of which can be described as ways to decouple a particular implementation of an object from code for the creation of such an object (Wikipedia). Instead, I am talking about the “factories” for replacing fixtures in tests — something which has seemingly obsessed the Ruby (Rails, especially) community. The two primary Ruby libraries for factory-based fixture replacement are factory_girl and Machinist. A tool such as Machinist or factory_girl generates data for the attributes you don’t care about, and constructs any necessary associated objects, leaving you to specify only the fields you care about in your test (from Machinist’s own README file). This sounds nice at first, because it makes your tests more readable and relevant. However, behind the scenes, these tools are still creating other objects and entities and introducing them into your test environment. By having data and objects in tests that are irrelevant to the functionality that is being tested (in isolation, remember), a developer creates an environment that permits, if not invites, silent dependencies to creep into an implementation. Furthermore, and perhaps more significantly, by creating objects (and usually entire hierarchies of objects) with such ease and opacity, you are outright masking the dependencies (*cough* complexity *cough* coupling) between your implementation and those entities. If forced to stub out all those intricacies, the system complexity would be screamingly obvious and a developer would quickly avail herself of a rewrite to reduce complexity or thin out the interface. Instead of having feedback that guides a developer to simplicity, fixture factories seem to guide developers to complexity by masking dependencies as one-line simplicity. In fact, that one (or five, whatever) line setup is a shotgun blast of environmental dependencies that are hidden from the architect. That complexity will come back for revenge after being ignored for so long. It seems that factory_girl and Machinist exist to make testing components more convenient. This is, at face value, an admirable and desirable goal. However, in unit tests, the cost is too high for any system of considerable size. Please, do the right thing and avoid the convenience and “fun” of the factory_girl temptress. You will trend towards a simpler system and as a bonus (in fact, an incredible one) your test suite will likely be exponentially faster which, in turn, will breed simplicity by letting you have more feedback more often. P.S. It shouldn’t go without mention that factories can be absolutely awesome for integration tests. Integration tests aren’t used for guiding system design nor testing in isolation so the drawbacks of these tools drop away. However, both factory_girl and Machinist use RSpec as some of their very first usage examples and this troubles me deeply. P.P.S. A lot of these arguments can be applied to fixtures too. However, they usually don’t create hordes of objects invisibly and litter your environment with them. Also, they aren’t as slow. But yes, the fewer factories and fixtures in a test, the better. Update for clarity: Firstly, I am absolutely just talking about unit tests. If you are testing code that integrates with ActiveRecord or number of levels of your stack, then factories and fixtures are certainly defensible (though I still prefer to steer clear). Secondly, I’ve tried to be careful about where I use the words simple, easy, complex, and difficult. For the definitions that I intend, please watch (at least the first 10 minutes of) Simple Made Easy." />
<meta property="og:description" content="Having maintainable code is great. Maintainable code allows you to deliver improvements faster, happier, and more reliably. Furthermore, the measures that developers need to take and the strategies that we have to employ to achieve maintainable code have been understood for years, if not decades. Especially in the realm of object-oriented programming, but certainly not exclusively, most of these principles boil down to reducing coupling and system complexity. A system whose parts are coupled as loosely as possible is a modular system; the parts know little of each other and a lot about themselves and they have thin and specific interfaces between each other. Test-driven development is one of the many tools at a developer’s disposal to achieve code quality. Unfortunately, there is a lot of naïveté around the benefits of TDD. A lot of developers see TDD as primarily a tool for verifying system correctness. While TDD does of course offer this benefit, and arguably better than retroactive automated testing, the real benefit of TDD is that it offers short feedback loops that guide the design/architecture of the system. Since it is accepted that a loosely-coupled modular system is a simpler system, it stands that tools, such as TDD, which guide a design towards modularity and simplicity are good tools. A module that is tightly coupled to another is not easily tested in isolation. However, if the isolated tests are written first, it is difficult to write a passing implementation for that module that maintains such a low degree of coupling. Therefore, good TDD should guide you towards a simpler design (though it is certainly not the only way). Unfortunately, factories work against this goal. Factories debilitate TDD’s ability to give you feedback into the complexity of your design. To be clear, I am not talking about the Factory Method Pattern or the Abstract Factory Pattern — both of which can be described as ways to decouple a particular implementation of an object from code for the creation of such an object (Wikipedia). Instead, I am talking about the “factories” for replacing fixtures in tests — something which has seemingly obsessed the Ruby (Rails, especially) community. The two primary Ruby libraries for factory-based fixture replacement are factory_girl and Machinist. A tool such as Machinist or factory_girl generates data for the attributes you don’t care about, and constructs any necessary associated objects, leaving you to specify only the fields you care about in your test (from Machinist’s own README file). This sounds nice at first, because it makes your tests more readable and relevant. However, behind the scenes, these tools are still creating other objects and entities and introducing them into your test environment. By having data and objects in tests that are irrelevant to the functionality that is being tested (in isolation, remember), a developer creates an environment that permits, if not invites, silent dependencies to creep into an implementation. Furthermore, and perhaps more significantly, by creating objects (and usually entire hierarchies of objects) with such ease and opacity, you are outright masking the dependencies (*cough* complexity *cough* coupling) between your implementation and those entities. If forced to stub out all those intricacies, the system complexity would be screamingly obvious and a developer would quickly avail herself of a rewrite to reduce complexity or thin out the interface. Instead of having feedback that guides a developer to simplicity, fixture factories seem to guide developers to complexity by masking dependencies as one-line simplicity. In fact, that one (or five, whatever) line setup is a shotgun blast of environmental dependencies that are hidden from the architect. That complexity will come back for revenge after being ignored for so long. It seems that factory_girl and Machinist exist to make testing components more convenient. This is, at face value, an admirable and desirable goal. However, in unit tests, the cost is too high for any system of considerable size. Please, do the right thing and avoid the convenience and “fun” of the factory_girl temptress. You will trend towards a simpler system and as a bonus (in fact, an incredible one) your test suite will likely be exponentially faster which, in turn, will breed simplicity by letting you have more feedback more often. P.S. It shouldn’t go without mention that factories can be absolutely awesome for integration tests. Integration tests aren’t used for guiding system design nor testing in isolation so the drawbacks of these tools drop away. However, both factory_girl and Machinist use RSpec as some of their very first usage examples and this troubles me deeply. P.P.S. A lot of these arguments can be applied to fixtures too. However, they usually don’t create hordes of objects invisibly and litter your environment with them. Also, they aren’t as slow. But yes, the fewer factories and fixtures in a test, the better. Update for clarity: Firstly, I am absolutely just talking about unit tests. If you are testing code that integrates with ActiveRecord or number of levels of your stack, then factories and fixtures are certainly defensible (though I still prefer to steer clear). Secondly, I’ve tried to be careful about where I use the words simple, easy, complex, and difficult. For the definitions that I intend, please watch (at least the first 10 minutes of) Simple Made Easy." />
<link rel="canonical" href="https://bjeanes.com/2012/02/factories-breed-complexity/" />
<meta property="og:url" content="https://bjeanes.com/2012/02/factories-breed-complexity/" />
<meta property="og:site_name" content="Bo Jeanes" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2012-02-26T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@bjeanes" />
<meta name="twitter:creator" content="@bjeanes" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"https://bjeanes.com/2012/02/factories-breed-complexity/"},"description":"Having maintainable code is great. Maintainable code allows you to deliver improvements faster, happier, and more reliably. Furthermore, the measures that developers need to take and the strategies that we have to employ to achieve maintainable code have been understood for years, if not decades. Especially in the realm of object-oriented programming, but certainly not exclusively, most of these principles boil down to reducing coupling and system complexity. A system whose parts are coupled as loosely as possible is a modular system; the parts know little of each other and a lot about themselves and they have thin and specific interfaces between each other. Test-driven development is one of the many tools at a developer’s disposal to achieve code quality. Unfortunately, there is a lot of naïveté around the benefits of TDD. A lot of developers see TDD as primarily a tool for verifying system correctness. While TDD does of course offer this benefit, and arguably better than retroactive automated testing, the real benefit of TDD is that it offers short feedback loops that guide the design/architecture of the system. Since it is accepted that a loosely-coupled modular system is a simpler system, it stands that tools, such as TDD, which guide a design towards modularity and simplicity are good tools. A module that is tightly coupled to another is not easily tested in isolation. However, if the isolated tests are written first, it is difficult to write a passing implementation for that module that maintains such a low degree of coupling. Therefore, good TDD should guide you towards a simpler design (though it is certainly not the only way). Unfortunately, factories work against this goal. Factories debilitate TDD’s ability to give you feedback into the complexity of your design. To be clear, I am not talking about the Factory Method Pattern or the Abstract Factory Pattern — both of which can be described as ways to decouple a particular implementation of an object from code for the creation of such an object (Wikipedia). Instead, I am talking about the “factories” for replacing fixtures in tests — something which has seemingly obsessed the Ruby (Rails, especially) community. The two primary Ruby libraries for factory-based fixture replacement are factory_girl and Machinist. A tool such as Machinist or factory_girl generates data for the attributes you don’t care about, and constructs any necessary associated objects, leaving you to specify only the fields you care about in your test (from Machinist’s own README file). This sounds nice at first, because it makes your tests more readable and relevant. However, behind the scenes, these tools are still creating other objects and entities and introducing them into your test environment. By having data and objects in tests that are irrelevant to the functionality that is being tested (in isolation, remember), a developer creates an environment that permits, if not invites, silent dependencies to creep into an implementation. Furthermore, and perhaps more significantly, by creating objects (and usually entire hierarchies of objects) with such ease and opacity, you are outright masking the dependencies (*cough* complexity *cough* coupling) between your implementation and those entities. If forced to stub out all those intricacies, the system complexity would be screamingly obvious and a developer would quickly avail herself of a rewrite to reduce complexity or thin out the interface. Instead of having feedback that guides a developer to simplicity, fixture factories seem to guide developers to complexity by masking dependencies as one-line simplicity. In fact, that one (or five, whatever) line setup is a shotgun blast of environmental dependencies that are hidden from the architect. That complexity will come back for revenge after being ignored for so long. It seems that factory_girl and Machinist exist to make testing components more convenient. This is, at face value, an admirable and desirable goal. However, in unit tests, the cost is too high for any system of considerable size. Please, do the right thing and avoid the convenience and “fun” of the factory_girl temptress. You will trend towards a simpler system and as a bonus (in fact, an incredible one) your test suite will likely be exponentially faster which, in turn, will breed simplicity by letting you have more feedback more often. P.S. It shouldn’t go without mention that factories can be absolutely awesome for integration tests. Integration tests aren’t used for guiding system design nor testing in isolation so the drawbacks of these tools drop away. However, both factory_girl and Machinist use RSpec as some of their very first usage examples and this troubles me deeply. P.P.S. A lot of these arguments can be applied to fixtures too. However, they usually don’t create hordes of objects invisibly and litter your environment with them. Also, they aren’t as slow. But yes, the fewer factories and fixtures in a test, the better. Update for clarity: Firstly, I am absolutely just talking about unit tests. If you are testing code that integrates with ActiveRecord or number of levels of your stack, then factories and fixtures are certainly defensible (though I still prefer to steer clear). Secondly, I’ve tried to be careful about where I use the words simple, easy, complex, and difficult. For the definitions that I intend, please watch (at least the first 10 minutes of) Simple Made Easy.","@type":"BlogPosting","url":"https://bjeanes.com/2012/02/factories-breed-complexity/","name":null,"headline":"Factories breed complexity","dateModified":"2012-02-26T00:00:00+00:00","datePublished":"2012-02-26T00:00:00+00:00","sameAs":null,"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://avatars2.githubusercontent.com/u/2560?s=200&v=4"},"name":"Bo Jeanes"},"image":null,"author":{"@type":"Person","name":"Bo Jeanes"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body class="black-80 ">



<div class="flex-l justify-between items-center mw7 mw8-l w-100 center pt3 pb3 pl3 pr3-ns ph4-m">

<a class="black-80 hover-black-80 link f2 f3-l fw4 mr3" href="https://bjeanes.com/" title="Home">Bo Jeanes</a>


  <div class="flex-l items-center mt3 mt0-l">
    <nav class="nowrap overflow-x-auto">
    
      
      <a href="https://bjeanes.com/archive/" class="black-80 hover-black-80 link f4 f5-l fw3 mr3 mt2" >Blog</a>
    
      
      <a href="mailto:blog@bjeanes.com" class="black-80 hover-black-80 link f4 f5-l fw3 mr3 mt2" >Contact</a>
    
    </nav>
  </div>
</div>










<main class="flex flex-column items-center">
  <article class="mw7 w-100 ph3 ph4-ns">

    <header class="">
    
    




<div class="flex w-100 mt4 lh-copy">
  <div class="pt1 pt0-ns">
    
      <a href="http://bjeanes.com" target="_blank"><img src="/assets/images/bo.jpg" alt="Bo Jeanes" class="w2 h2 w3-ns h3-ns br-100"></a>
    
  </div>

  <div class="flex flex-column w-90 w-80-ns pl2 pl3-ns">
    <div class="flex items-center">
      
      <a class="f5 fw4 lh-title black-80 hover-black-80 link mr2" href="http://bjeanes.com" target="_blank">Bo Jeanes</a>
      

      
      <a class="f6 fw4 lh-copy link nested-author-cta ba br-pill ph2" href="https://twitter.com/bjeanes" target="_blank">Follow</a>
      
    </div>

    <div class="f6 fw3 lh-copy silver"></div>

    <div class="f6 fw3 lh-copy silver">
      
      <span><time>26 Feb 2012</time></span>
      

      <span class="ttl"> &middot;
        



  
	  4 min read
	


      </span>
    </div>
  </div>
</div>


    

    
    <h1 class="f2 fw6 lh-title mb1">Factories breed complexity</h1>
    
    
    </header>


    <div class="mw7 w-100 f5 f4-ns fw3 lh-copy mb0">
    <p>Having maintainable code is great. Maintainable code allows you to deliver improvements faster, happier, and more reliably.</p>

<p>Furthermore, the measures that developers need to take and the strategies that we have to employ to achieve maintainable code have been understood for years, if not decades. Especially in the realm of object-oriented programming, but certainly not exclusively, most of these principles boil down to reducing coupling and system complexity. A system whose parts are coupled as loosely as possible is a modular system; the parts know little of each other and a lot about themselves and they have thin and specific interfaces between each other.</p>

<p>Test-driven development is one of the many tools at a developer’s disposal to achieve code quality. Unfortunately, there is a lot of naïveté around the benefits of TDD. A lot of developers see TDD as primarily a tool for verifying system correctness. While TDD does of course offer this benefit, and arguably better than retroactive automated testing, the real benefit of TDD is that it offers short feedback loops that guide the design/architecture of the system.</p>

<p>Since it is accepted that a loosely-coupled modular system is a simpler system, it stands that tools, such as TDD, which guide a design towards modularity and simplicity are good tools. A module that is tightly coupled to another is not easily tested in isolation. However, if the isolated tests are written first, it is difficult to write a passing implementation for that module that maintains such a low degree of coupling. Therefore, good TDD should guide you towards a simpler design (though it is certainly not the only way).</p>

<p>Unfortunately, factories work against this goal. Factories debilitate TDD’s ability to give you feedback into the complexity of your design.</p>

<p>To be clear, I am not talking about the <a href="http://en.wikipedia.org/wiki/Factory_method_pattern">Factory Method Pattern</a>
or the <a href="http://en.wikipedia.org/wiki/Abstract_factory_pattern">Abstract Factory Pattern</a> — both of which can be described
as ways to <q src="http://en.wikipedia.org/wiki/Object_creation#Creating_objects">decouple a particular implementation
of an object from code for the creation of such an object</q> (<cite><a href="http://en.wikipedia.org/wiki/Object_creation#Creating_objects">Wikipedia</a></cite>). Instead, I am talking about the “factories” for replacing fixtures in tests — something which has seemingly obsessed the Ruby (Rails, especially) community. The two primary Ruby libraries for factory-based fixture replacement are <a href="https://github.com/thoughtbot/factory_girl">factory_girl</a> and <a href="https://github.com/notahat/machinist">Machinist</a>.</p>

<p>A tool such as Machinist or factory_girl <q>generates data for the attributes you don’t care about, and constructs any necessary associated objects, leaving you to specify only the fields you care about in your test</q> (from Machinist’s own <a href="https://github.com/notahat/machinist/blob/master/README.markdown">README file</a>). This sounds nice at first, because it makes your tests more readable and relevant. However, behind the scenes, these tools are still creating other objects and entities and introducing them into your test environment. By having data and objects in tests that are irrelevant to the functionality that is being tested (in <em>isolation</em>, remember), a developer creates an environment that permits, if not invites, silent dependencies to creep into an implementation.</p>

<p>Furthermore, and perhaps more significantly, by creating objects (and usually entire <em>hierarchies</em> of objects) with such ease and opacity, you are outright masking the dependencies (*cough* complexity *cough* coupling) between your implementation and those entities. If forced to stub out all those intricacies, the system complexity would be screamingly obvious and a developer would quickly avail herself of a rewrite to reduce complexity or thin out the interface.</p>

<p>Instead of having feedback that guides a developer to simplicity, fixture factories seem to guide developers to complexity by masking dependencies as one-line simplicity. In fact, that one (or five, whatever) line setup is a shotgun blast of environmental dependencies that are hidden from the architect. That complexity will come back for revenge after being ignored for so long.</p>

<p>It seems that factory_girl and Machinist exist to make testing components more convenient. This is, at face value, an admirable and desirable goal. However, in unit tests, the cost is too high for any system of considerable size.</p>

<p>Please, do the right thing and avoid the convenience and “fun” of the factory_girl temptress. You will trend towards a simpler system and as a bonus (in fact, an incredible one) your test suite will likely be exponentially faster which, in turn, will breed simplicity by letting you have more feedback more often.</p>

<p>P.S. It shouldn’t go without mention that factories can be absolutely awesome for integration tests. Integration tests aren’t used for guiding system design nor testing in isolation so the drawbacks of these tools drop away. However, both factory_girl and Machinist use RSpec as some of their very first usage examples and this troubles me deeply.</p>

<p>P.P.S. A lot of these arguments can be applied to fixtures too. However, they usually don’t create hordes of objects invisibly and litter your environment with them. Also, they aren’t as slow. But yes, the fewer factories <em>and</em> fixtures in a test, the better.</p>

<p><strong>Update for clarity</strong>: Firstly, I am absolutely just talking about unit tests. If you are testing code that <em>integrates</em> with ActiveRecord or number of levels of your stack, then factories and fixtures are certainly defensible (though I still prefer to steer clear). Secondly, I’ve tried to be careful about where I use the words simple, easy, complex, and difficult. For the definitions that I intend, please watch (at least the first 10 minutes of) <a href="http://www.infoq.com/presentations/Simple-Made-Easy">Simple Made Easy</a>.</p>

    </div>

    <div class="mw7 w-100 lh-copy">
    
    
<div class="flex flex-row justify-start flex-wrap list mb2">
  

  

  

</div>

    

    
    
<div class="flex flex-row justify-end">


  <a class="link black-60 hover-dark-gray w2 ml3" href="https://twitter.com/intent/tweet?text=Factories breed complexity https://bjeanes.com/2012/02/factories-breed-complexity/" title="Share on Twitter" aria-hidden="true">
    <svg viewBox="0 0 20 20" data-icon="twitter" style="fill:currentcolor">
      <path xmlns="http://www.w3.org/2000/svg" d="M14.467,6.707c-0.34,0.198-0.715,0.342-1.115,0.419c-0.318-0.335-0.775-0.545-1.279-0.545c-0.969,0-1.754,0.773-1.754,1.727c0,0.135,0.015,0.267,0.045,0.394C8.905,8.628,7.612,7.94,6.747,6.896C6.596,7.151,6.509,7.448,6.509,7.764c0,0.599,0.31,1.128,0.78,1.438C7.002,9.192,6.732,9.115,6.495,8.985c0,0.007,0,0.014,0,0.021c0,0.837,0.605,1.535,1.408,1.694c-0.147,0.04-0.302,0.06-0.462,0.06c-0.113,0-0.223-0.011-0.33-0.031c0.223,0.687,0.871,1.186,1.638,1.199c-0.6,0.464-1.356,0.739-2.179,0.739c-0.142,0-0.281-0.007-0.418-0.023c0.777,0.489,1.699,0.775,2.689,0.775c3.228,0,4.991-2.63,4.991-4.913c0-0.075-0.002-0.149-0.004-0.223c0.342-0.244,0.639-0.547,0.875-0.894c-0.316,0.137-0.652,0.23-1.008,0.272C14.057,7.448,14.336,7.11,14.467,6.707 M10,0.594c-5.195,0-9.406,4.211-9.406,9.406c0,5.195,4.211,9.406,9.406,9.406c5.196,0,9.407-4.211,9.407-9.406C19.406,4.805,15.195,0.594,10,0.594 M10,18.552c-4.723,0-8.551-3.829-8.551-8.552S5.277,1.449,10,1.449c4.723,0,8.551,3.829,8.551,8.551S14.723,18.552,10,18.552"></path>
    </svg>
  </a>



  <a class="link black-60 hover-dark-gray w2 ml3" href="https://www.facebook.com/sharer/sharer.php?u=https://bjeanes.com/2012/02/factories-breed-complexity/" title="Share on Facebook" aria-hidden="true">
    <svg viewBox="0 0 20 20" data-icon="facebook" style="fill:currentcolor">
      <path xmlns="http://www.w3.org/2000/svg" d="M10,0.5c-5.247,0-9.5,4.253-9.5,9.5c0,5.247,4.253,9.5,9.5,9.5c5.247,0,9.5-4.253,9.5-9.5C19.5,4.753,15.247,0.5,10,0.5 M10,18.637c-4.77,0-8.636-3.867-8.636-8.637S5.23,1.364,10,1.364S18.637,5.23,18.637,10S14.77,18.637,10,18.637 M10.858,7.949c0-0.349,0.036-0.536,0.573-0.536h0.719v-1.3H11c-1.38,0-1.866,0.65-1.866,1.743v0.845h-0.86V10h0.86v3.887h1.723V10h1.149l0.152-1.299h-1.302L10.858,7.949z"></path>
    </svg>
  </a>




  <a class="link black-60 hover-dark-gray w2 ml3" href="https://plus.google.com/share?url=https://bjeanes.com/2012/02/factories-breed-complexity/" title="Share on Google+" aria-hidden="true">
    <svg viewBox="0 0 20 20" data-icon="google plus" style="fill:currentcolor">
      <path xmlns="http://www.w3.org/2000/svg" d="M10,0.562c-5.212,0-9.438,4.226-9.438,9.438c0,5.213,4.226,9.438,9.438,9.438c5.212,0,9.438-4.225,9.438-9.438C19.438,4.788,15.212,0.562,10,0.562 M10,18.58c-4.738,0-8.58-3.841-8.58-8.58c0-4.738,3.842-8.58,8.58-8.58c4.737,0,8.579,3.841,8.579,8.58C18.579,14.739,14.737,18.58,10,18.58 M10.033,10.346C9.813,10.183,9.608,9.94,9.6,9.865c0-0.128,0-0.188,0.303-0.435c0.393-0.322,0.609-0.745,0.609-1.192c0-0.387-0.108-0.731-0.293-0.982h0.164l0.908-0.688H8.832c-0.986,0-1.851,0.774-1.851,1.657c0,0.912,0.667,1.604,1.565,1.642C8.533,9.933,8.525,9.996,8.525,10.06c0,0.131,0.03,0.257,0.09,0.378c-1.113,0.007-2.05,0.752-2.05,1.632c0,0.789,0.902,1.362,2.145,1.362c1.343,0,2.067-0.84,2.067-1.631C10.778,11.143,10.576,10.748,10.033,10.346 M8.026,8.198C7.985,7.869,8.054,7.565,8.212,7.384c0.096-0.11,0.22-0.169,0.358-0.169V7.036l0.016,0.179c0.412,0.014,0.807,0.501,0.88,1.086c0.042,0.335-0.03,0.647-0.191,0.833c-0.096,0.11-0.217,0.169-0.367,0.168h0C8.503,9.29,8.1,8.784,8.026,8.198 M8.707,12.749c-0.612,0-1.093-0.394-1.093-0.897c0-0.461,0.562-0.865,1.202-0.865v-0.18h0l0.017,0.18c0.138,0.002,0.272,0.022,0.399,0.062l0.126,0.092c0.326,0.231,0.498,0.363,0.549,0.575c0.013,0.056,0.019,0.111,0.019,0.167C9.927,12.458,9.517,12.749,8.707,12.749M13.43,6.993h-0.858v1.288H11.28V9.14h1.291v1.283h0.858V9.14h1.293V8.281H13.43V6.993z"></path>
    </svg>
  </a>


</div>


    

    
    



<div class="flex w-100 mt2 lh-copy bt b--light-gray pv3">
  <div>
    
      <a href="http://bjeanes.com" target="_blank"><img src="/assets/images/bo.jpg" alt="Bo Jeanes" class="w2 h2 w3-ns h3-ns br-100"></a>
    
  </div>

  <div class="flex flex-column w-90 w-80-ns pl2 pl3-ns">
    <div class="flex items-center-ns">
      
      <a class="f5 f4-ns fw4 lh-title black-80 hover-black-80 link mr2" href="http://bjeanes.com" target="_blank">Bo Jeanes</a>
      

      
      <a class="f6 fw4 link nested-author-cta ba br-pill ph2" href="https://twitter.com/bjeanes" target="_blank">Follow</a>
      
    </div>


    <div class="f6 f5-ns fw3 lh-copy silver">Bo is a software engineer who cares deeply about simplicity in design and
building complex behaviours out of simple primitives. Bo primarily works in
Ruby day-to-day, though is a functional programmer at heart and a fan of
programming languages generally, with particular soft spots for Clojure,
Elixir, and Rust.
</div>
  </div>

</div>



    

    

    
    <script
  src="https://utteranc.es/client.js"
  repo="bjeanes/bjeanes.github.io"
  issue-term="og:title"
  label="blog-comments"
  theme="github-light"
  crossorigin="anonymous"
  async
></script>
<noscript
  >Go to
  <a href="https://github.com/bjeanes/bjeanes.github.io/issues">GH issues</a> to
  view/leave comments</noscript
>

    
    </div>

  </article>
</main>




<footer class="flex justify-start items-baseline mw7 center w-100 ph3 ph4-ns mt4 mb2 lh-copy">
  <nav class="flex flex-row flex-wrap">
    <span class="f7 fw3 silver mr3 ttc"><a href="https://bjeanes.com/" class="f7 fw5 silver hover-silver link underline-hover" title="Bo Jeanes">Bo jeanes</a> &copy; 2020</span>
    

    
    <span class="f7 fw3 silver mr3">Designed with <a href="https://desiredpersona.com/themes/" class="f7 fw3 silver hover-silver link underline-hover mr3" target="_blank">Minimal Theme</a></span>
    
  </nav>
</footer>



</body>
</html>
